---
title: "Minto Pike Mark-Recapture"
output: word_document
date: "2025-10-21"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, dpi=300, fig.width = 7, fig.height = 7)
```

```{r, message=FALSE, results='hide', warning=FALSE}
library(tidyverse)
library(janitor)
library(recapr)
library(dsftools)
library(knitr)

# loading some helper functions
source("FDS_2025/R/recapr_prep.R")

# reading raw data
event1_raw <- read_csv("FDS_2025/flat_data/event1.csv", skip=1) %>%
  remove_empty() %>%
  filter(!is.na(Unique)) %>%
  mutate(`Tag Number` = as.character(`Tag Number`)) %>%
  rename(FL = `Fork Length (mm)`)
event2_raw <- read_csv("FDS_2025/flat_data/event2.csv", skip=1) %>%
  remove_empty() %>%
  filter(!is.na(Unique)) %>%
  mutate(`Tag Number` = as.character(`Tag Number`)) %>%
  rename(FL = `Fork Length (mm)`) %>%
  rename(FLc = `Fork Length Corrected (mm)`) %>%
  mutate(gear = sapply(strsplit(Comments, split="Gear= "), "[", 2)) %>%
  mutate(gear = factor(ifelse(gear=="G", "GN", gear)))

# creating truncated data tables
# c for corrected (length correction)
event1_550 <- event1_raw %>%
  filter(FL >= 550)
event2_550 <- event2_raw %>%
  filter(FL >= 550)
event2_550c <- event2_raw %>%
  filter(FLc >= 550)
event1_600 <- event1_raw %>%
  filter(FL >= 600)
event2_600 <- event2_raw %>%
  filter(FL >= 600)
event2_600c <- event2_raw %>%
  filter(FLc >= 600)


# creating MR objects from recapr_prep
mr550 <- recapr_prep(ID="Tag Number", event1=event1_550, event2=event2_550)
mr600 <- recapr_prep(ID="Tag Number", event1=event1_600, event2=event2_600)
mr550c <- recapr_prep(ID="Tag Number", event1=event1_550, event2=event2_550c)
mr600c <- recapr_prep(ID="Tag Number", event1=event1_600, event2=event2_600c)

mr_all <- recapr_prep(ID="Tag Number", event1=event1_raw, event2=event2_raw)

# creating stratified MR objects (all possible ways)
mr550_strat <- stratify(mr550,
                        event_names = c("event1", "event2"),
                        column_names = c("FL","FL"),
                        breaks = c(550, 650, 1200))
mr600_strat <- stratify(mr600,
                        event_names = c("event1", "event2"),
                        column_names = c("FL","FL"),
                        breaks = c(600, 650, 1200))
mr550c_strat <- stratify(mr550c,
                        event_names = c("event1", "event2"),
                        column_names = c("FL","FLc"),
                        breaks = c(550, 650, 1200))
mr600c_strat <- stratify(mr600c,
                        event_names = c("event1", "event2"),
                        column_names = c("FL","FLc"),
                        breaks = c(600, 650, 1200))

# growth_pval <- round(t.test(mr550_strat$recaps$matched$FL_event2 - mr550_strat$recaps$matched$FL_event1, alternative = "greater")$p.value, 2)
# growth_est <- round(mean(mr550_strat$recaps$matched$FL_event2 - mr550_strat$recaps$matched$FL_event1),2)
# growth_se <- round(dsftools::se(mr550_strat$recaps$matched$FL_event2 - mr550_strat$recaps$matched$FL_event1),2)

# growth_ttest <- t.test(mr600_strat$recaps$matched$FL_event2 - mr600_strat$recaps$matched$FL_event1, alternative = "greater")
# growth_pval <- round(growth_ttest$p.value, 2)
# growth_tstat <- round(growth_ttest$statistic, 2)
# growth_df <- round(growth_ttest$parameter)
# 
# growth_est <- round(mean(mr600_strat$recaps$matched$FL_event2 - mr600_strat$recaps$matched$FL_event1),2)
# growth_se <- round(dsftools::se(mr600_strat$recaps$matched$FL_event2 - mr600_strat$recaps$matched$FL_event1),2)


## It might make the most sense to estimate growth from ALL recaptured fish, not
## just those above 550 or 600mm
growth_ttest <- t.test(mr_all$recaps$matched$FL_event2 - mr_all$recaps$matched$FL_event1, alternative = "greater")
growth_pval <- round(growth_ttest$p.value, 2)
growth_tstat <- round(growth_ttest$statistic, 2)
growth_df <- round(growth_ttest$parameter)

growth_est <- round(mean(mr_all$recaps$matched$FL_event2 - mr_all$recaps$matched$FL_event1),2)
growth_se <- round(dsftools::se(mr_all$recaps$matched$FL_event2 - mr_all$recaps$matched$FL_event1),2)
```

## Overview

To facilitate possible correction for bias induced by incomplete migration from the MLSA to the CROA, abundance and length composition were estimated using length-stratified estimators, with a break point at 650 mm FL.  Since no radiotagged pike $\geq$ 650 mm FL were observed to stay in the MLSA overwinter, it was assumed that this length stratum would be free of bias due to immigration.

Growth between events was tested using all the recorded lengths of fish captured during both events.  It is worth noting that these results use all recaptured fish, with no lower truncation at 600 mm.  A one-tailed paired t-test yielded a p-value of `r growth_pval` (t = `r growth_tstat` on `r growth_df` degrees of freedom), indicating no evidence of positive growth.  The estimated growth was, in fact, negative, with an estimate of `r growth_est` mm FL (SE `r growth_se` mm FL).  This could be interpreted as evidence of slight measurement bias, likely during the winter.  The results presented here do not account for growth; however, the inferences of a growth-corrected estimate are compared at the end of this document.  Instead of physical growth, a "corrected" estimate could be interpreted as correcting for possible measurement bias.

Sample sizes for uncorrected strata are presented below.

```{r}
# n1 <- table(mr550_strat$input_data$event1$FL_strat)
# n2 <- table(mr550_strat$input_data$event2$FL_strat)
# m2_1 <- table(mr550_strat$recaps$matched$FL_strat_event1)
# m2_2 <- table(mr550_strat$recaps$matched$FL_strat_event2)

n1 <- table(mr600_strat$input_data$event1$FL_strat)
n2 <- table(mr600_strat$input_data$event2$FL_strat)
m2_1 <- table(mr600_strat$recaps$matched$FL_strat_event1)
m2_2 <- table(mr600_strat$recaps$matched$FL_strat_event2)

cbind(n1, n2, m2=m2_1) %>% kable
```

Size selectivity in both samples was evaluated using Kolmogorov-Smirnov (KS) tests using the recorded lengths of marked, captured, and recaptured individuals.  Tests indicated strong evidence of length selectivity in the first event for all samples, as well as weak evidence of length selectivity in the first event for the smaller length stratum.  Abundance estimates may be considered unbiased and germane to the first event, but estimates of length composition were calculated using only the second-event sample due to the likely presence of size selectivity in the first event.  

It is worth noting that an abundance estimate that is germane to the first event may still be unbiased in the presence of length selectivity in the first event, provided that emigration from the sampled population (i.e. outside the MLSA) is independent of size.  Note: I had to write a simulation to convince myself of this!

## KS tests


```{r, fig.width=9, fig.height=4}
par(family="serif")
# par(mfrow=c(1,2))
# with(mr550_strat,
#      ksplot(input_data$event1$FL,
#             recaps$matched$FL_event1,
#             col=c(1,2), legend=c("Event 1", "Recaps"), main="All samples"))
# with(mr550_strat,
#      ksplot(input_data$event2$FL,
#             recaps$matched$FL_event2,
#             col=c(1,4), legend=c("Event 2", "Recaps"), main="All samples"))

par(mfrow=c(1,2))
with(mr600_strat,
     ksplot(input_data$event1$FL,
            recaps$matched$FL_event1,
            col=c(1,2), legend=c("Event 1", "Recaps"), main="All samples"))
with(mr600_strat,
     ksplot(input_data$event2$FL,
            recaps$matched$FL_event2,
            col=c(1,4), legend=c("Event 2", "Recaps"), main="All samples"))
with(mr600_strat,
     ksplot(input_data$event1$FL,
            input_data$event2$FL,
            col=c(2,4), legend=c("Event 1", "Event 2"), main="All samples"))
```

```{r, fig.width=9, fig.height=4}
par(family="serif")
par(mfrow=c(1,2))
# with(mr550_strat,
#      ksplot(input_data$event1$FL %s_l% 650,
#             recaps$matched$FL_event1 %s_l% 650,
#             col=c(1,2), legend=c("Event 1", "Recaps"), main="550 - 649 mm"))
# with(mr550_strat,
#      ksplot(input_data$event2$FL %s_l% 650,
#             recaps$matched$FL_event2 %s_l% 650,
#             col=c(1,4), legend=c("Event 2", "Recaps"), main="550 - 649 mm"))
# with(mr550_strat,
#      ksplot(input_data$event1$FL %s_geq% 650,
#             recaps$matched$FL_event1 %s_geq% 650,
#             col=c(1,2), legend=c("Event 1", "Recaps"), main="650 mm +"))
# with(mr550_strat,
#      ksplot(input_data$event2$FL %s_geq% 650,
#             recaps$matched$FL_event2 %s_geq% 650,
#             col=c(1,4), legend=c("Event 2", "Recaps"), main="650 mm +"))

with(mr600_strat,
     ksplot(input_data$event1$FL %s_l% 650,
            recaps$matched$FL_event1 %s_l% 650,
            col=c(1,2), legend=c("Event 1", "Recaps"), main="600 - 649 mm"))
with(mr600_strat,
     ksplot(input_data$event2$FL %s_l% 650,
            recaps$matched$FL_event2 %s_l% 650,
            col=c(1,4), legend=c("Event 2", "Recaps"), main="600 - 649 mm"))
with(mr600_strat,
     ksplot(input_data$event1$FL %s_l% 650,
            input_data$event2$FL %s_l% 650,
            col=c(2,4), legend=c("Event 1", "Event 2"), main="600 - 649 mm"))

with(mr600_strat,
     ksplot(input_data$event1$FL %s_geq% 650,
            recaps$matched$FL_event1 %s_geq% 650,
            col=c(1,2), legend=c("Event 1", "Recaps"), main="650 mm +"))
with(mr600_strat,
     ksplot(input_data$event2$FL %s_geq% 650,
            recaps$matched$FL_event2 %s_geq% 650,
            col=c(1,4), legend=c("Event 2", "Recaps"), main="650 mm +"))
with(mr600_strat,
     ksplot(input_data$event1$FL %s_geq% 650,
            input_data$event2$FL %s_geq% 650,
            col=c(2,4), legend=c("Event 1", "Event 2"), main="650 mm +"))
```

\pagebreak

## Abundance Estimates & Length Composition

```{r}
Nhat_vec <- NChapman(n1, n2, m2_1)
seNhat_vec <-   seChapman(n1, n2, m2_1)
Nhat_strat <- Nstrat(n1, n2, m2_1)
seNhat_strat <- sestrat(n1, n2, m2_1)

# _f for formatted
ff <- function(x) formatC(x, digits=0, format="f", big.mark=",")
Nhat_vec_f <- paste0(ff(Nhat_vec), " (", ff(seNhat_vec), ")")
Nhat_strat_f <- paste0(ff(Nhat_strat), " (", ff(seNhat_strat), ")")
```

### Abundance

Abundance for each stratum was estimated as `r Nhat_vec_f[1]` and `r Nhat_vec_f[2]` for the **600**-649 mm and 650+ mm length strata, respectively.

Summing the stratum estimates and their respective variances yields an overall stratified estimate of `r Nhat_strat_f`.

### Length composition

Length composition was estimated using the samples from the second event, using stratified estimation as described below.

```{r}
# lengthbreaks <- c(550, 600, 650, 700, 800, 900, 1000, 1200) #550 to 1146
lengthbreaks <- c(600, 650, 700, 800, 900, 1000, 1200) #550 to 1146
# ASL_table(length_cat = cut(mr550_strat$input_data$event2$FL, breaks=lengthbreaks, right=FALSE, 
#                     dig.lab = 4),
#           stratum=as.numeric(mr550_strat$input_data$event2$FL_strat),
#           Nhat=as.numeric(Nhat_vec),
#           se_Nhat = as.numeric(seNhat_vec)) %>% 
#   kable(format.args=list(big.mark=','), digits=c(0,3,3,0,0))
ASL_table(length_cat = cut(mr600_strat$input_data$event2$FL, breaks=lengthbreaks, right=FALSE, 
                    dig.lab = 4),
          stratum=as.numeric(mr600_strat$input_data$event2$FL_strat),
          Nhat=as.numeric(Nhat_vec),
          se_Nhat = as.numeric(seNhat_vec)) %>% 
  kable(format.args=list(big.mark=','), digits=c(0,3,3,0,0))
```

```{r}
# For the purpose of comparison to similar studies, abundance of pike $\geq$ 600 mm FL was estimated using the stratified estimate of the proportion of pike $\geq$ 600 mm FL, applied to the stratified abundance estimate of pike $\geq$ 550 mm FL.  Results are tabulated below.
```

```{r}
# lengthbreaks <- c(550, 600, 1200) #550 to 1146
# ASL_table(length_cat = cut(mr550_strat$input_data$event2$FL, breaks=lengthbreaks, right=FALSE, 
#                     dig.lab = 4),
#           stratum=as.numeric(mr550_strat$input_data$event2$FL_strat),
#           Nhat=as.numeric(Nhat_vec),
#           se_Nhat = as.numeric(seNhat_vec)) %>% 
#   kable(format.args=list(big.mark=','), digits=c(0,3,3,0,0))
```

```{r}
# n1_600 <- table(mr600_strat$input_data$event1$FL_strat)
# n2_600 <- table(mr600_strat$input_data$event2$FL_strat)
# m2_1_600 <- table(mr600_strat$recaps$matched$FL_strat_event1)
# m2_2_600 <- table(mr600_strat$recaps$matched$FL_strat_event2)
# 
# Nhat_strat_600 <- Nstrat(n1_600, n2_600, m2_1_600)
# seNhat_strat_600 <- sestrat(n1_600, n2_600, m2_1_600)
# 
# # _f for formatted
# ff <- function(x) formatC(x, digits=0, format="f", big.mark=",")
# Nhat_strat_f_600 <- paste0(ff(Nhat_strat_600), " (", ff(seNhat_strat_600), ")")
```

```{r}
# This may be compared to a stratified abundance estimate of pike $\geq$ 600 mm FL as calculated only from fish $\geq$ 600 mm FL, which results in an estimated abundance of `r Nhat_strat_f_600`.
```

\pagebreak

### Length composition methodology

```{r, results='asis'}
# ASL_boilerplate(length_cat = cut(mr550_strat$input_data$event2$FL, breaks=lengthbreaks, 
#                           right=FALSE, dig.lab = 4),
#           stratum=as.numeric(mr550_strat$input_data$event2$FL_strat),
#           Nhat=as.numeric(Nhat_vec),
#           se_Nhat = as.numeric(seNhat_vec),
#           species="pike")
ASL_boilerplate(length_cat = cut(mr600_strat$input_data$event2$FL, breaks=lengthbreaks, 
                          right=FALSE, dig.lab = 4),
          stratum=as.numeric(mr600_strat$input_data$event2$FL_strat),
          Nhat=as.numeric(Nhat_vec),
          se_Nhat = as.numeric(seNhat_vec),
          species="pike")
```

\pagebreak

## Capture gear - **all fish in event 2**

```{r, fig.height=5, fig.width=7, message=FALSE, results='hide'}
# event2_550 %>%
#   ggplot(aes(x=gear, y=FL)) +
#   geom_boxplot() +
#   theme_bw()

# par(mfrow=c(1,2))
par(family="serif")

# nn <- table(event2_550$gear)
# labs <- paste0(names(nn), " (n=", nn, ")")
# thecols <- adjustcolor(rainbow(4), green.f=.75, red.f=.75, blue.f=.75)
# plot(NA, xlim=range(event1_550$FL), ylim=0:1, ylab="Cumulative Prop", xlab="FL (mm)")
# for(thegear in sort(unique(event2_550$gear))) {
#   plot(ecdf(event2_550$FL[event2_550$gear==thegear]), col=thecols[which(sort(unique(event2_550$gear))==thegear)], add=TRUE)
# }
# legend("bottomright", col=thecols, pch=16, lty=1, legend=labs, title="Capture Gear")
# boxplot(FL~gear, data=event2_550, col=thecols, names=labs, xlab="Capture Gear", ylab="FL (mm)")

# nn <- table(event2_600$gear)
# labs <- paste0(names(nn), " (n=", nn, ")")
# thecols <- adjustcolor(rainbow(4), green.f=.75, red.f=.75, blue.f=.75)
# plot(NA, xlim=range(event1_600$FL), ylim=0:1, ylab="Cumulative Prop", xlab="FL (mm)")
# for(thegear in sort(unique(event2_600$gear))) {
#   plot(ecdf(event2_600$FL[event2_600$gear==thegear]), col=thecols[which(sort(unique(event2_600$gear))==thegear)], add=TRUE)
# }
# legend("bottomright", col=thecols, pch=16, lty=1, legend=labs, title="Capture Gear")
# boxplot(FL~gear, data=event2_600, col=thecols, names=labs, xlab="Capture Gear", ylab="FL (mm)")



# nn <- table(event2_raw$gear)
# labs <- paste0(names(nn), " (n=", nn, ")")
# thecols <- adjustcolor(rainbow(4), green.f=.75, red.f=.75, blue.f=.75)
# plot(NA, xlim=range(event2_raw$FL), ylim=0:1, ylab="Cumulative Prop", xlab="FL (mm)")
# for(thegear in sort(unique(event2_raw$gear))) {
#   plot(ecdf(event2_raw$FL[event2_raw$gear==thegear]), col=thecols[which(sort(unique(event2_raw$gear))==thegear)], add=TRUE)
# }
# legend("bottomright", col=thecols, pch=16, lty=1, legend=labs, title="Capture Gear")
# boxplot(FL~gear, data=event2_raw, col=thecols, names=labs, xlab="Capture Gear", ylab="FL (mm)")


geartype_edit <- read_csv("FDS_2025/flat_data/geartype_edit.csv") %>%
  mutate(Gear_edit = ifelse(Gear=="P", "J", Gear))
table(geartype_edit$Gear_edit)


nn <- table(geartype_edit$Gear_edit)
labs <- paste0(names(nn), " (n=", nn, ")")
thecols <- adjustcolor(rainbow(4), green.f=.75, red.f=.75, blue.f=.75)
plot(NA, xlim=range(geartype_edit$FL), ylim=0:1, ylab="Cumulative Prop", xlab="FL (mm)")
for(thegear in sort(unique(geartype_edit$Gear_edit))) {
  plot(ecdf(geartype_edit$FL[geartype_edit$Gear_edit==thegear]), col=thecols[which(sort(unique(geartype_edit$Gear_edit))==thegear)], add=TRUE)
}
legend("bottomright", col=thecols, pch=16, lty=1, legend=labs, title="Capture Gear")
boxplot(FL~Gear_edit, data=geartype_edit, col=thecols, names=labs, xlab="Capture Gear", ylab="FL (mm)")

```

All pairwise differences in the distributions of lengths associated with capture gear types in the second event were tested using Kolmogorov-Smirnov (KS) tests, with a Šidák-corrected family-wise significance level of $\alpha^*=1-(1-0.05)^{\frac{1}{6}}$ = `r round(1-((1-.05)^(1/6)), 4)` assuming six possible comparisons.  A table of p-values is reported below, with values followed by ** denoting significant pairwise differences.

Note: I'm not sure if this is meaningful.  The story is much clearer from the plot, and the presence or absence of family-wise significant differences mostly seems to indicate large sample sizes.

```{r, warning=FALSE}
# pmat1 <- matrix(nrow=4, ncol=4)
# types <- sort(unique(event2_raw$gear))
# rownames(pmat1) <- colnames(pmat1) <- types
# 
# for(i in 1:3) {
#   for(j in (i+1):4) {
#     # pmat1[i,j] <- ks.test(event2_550$FL[event2_550$gear==types[i]],
#     #                      event2_550$FL[event2_550$gear==types[j]])$p.value
#     pmat1[i,j] <- ks.test(event2_raw$FL[event2_raw$gear==types[i]],
#                          event2_raw$FL[event2_raw$gear==types[j]])$p.value
#   }
# }
# 
# pmat2 <- pmat1[1:3,2:4]
# 
# a <- .05
# a_sidak <- 1-((1-a)^(1/6)) 
# # pmat2 < a_sidak
# 
# pmat3 <- ifelse(is.na(pmat2), "--",
#                 ifelse(pmat2 < 0.00001, "< 0.00001**",
#                        ifelse(pmat2 < a_sidak, paste0(format(round(pmat2, 5), scientific=FALSE), "**"),
#                        round(pmat2, 3))))
# 
# knitr::kable(pmat3, align="c")


pmat1 <- matrix(nrow=4, ncol=4)
types <- sort(unique(geartype_edit$Gear_edit))
rownames(pmat1) <- colnames(pmat1) <- types
Dmat1 <- diffmat1 <- SEmat1 <- pmat1

for(i in 1:3) {
  for(j in (i+1):4) {
    # pmat1[i,j] <- ks.test(event2_550$FL[event2_550$Gear_edit==types[i]],
    #                      event2_550$FL[event2_550$Gear_edit==types[j]])$p.value
    ks <- suppressWarnings(ks.test(geartype_edit$FL[geartype_edit$Gear_edit==types[i]],
                                   geartype_edit$FL[geartype_edit$Gear_edit==types[j]]))
    ttest <- suppressWarnings(t.test(geartype_edit$FL[geartype_edit$Gear_edit==types[i]],
                                   geartype_edit$FL[geartype_edit$Gear_edit==types[j]]))
    pmat1[i,j] <- ks$p.value
    Dmat1[i,j] <- ks$statistic
    diffmat1[i,j] <- -diff(ttest$estimate)
    SEmat1[i,j] <- ttest$stderr
  }
}

pmat2 <- pmat1[1:3,4:2]
Dmat2 <- Dmat1[1:3,4:2]
diffmat2 <- diffmat1[1:3,4:2]
SEmat2 <- SEmat1[1:3,4:2]

a <- .05
a_sidak <- 1-((1-a)^(1/6)) 
# pmat2 < a_sidak

pmat3 <- ifelse(is.na(pmat2), "",  ## "--"
                ifelse(pmat2 < 0.00001, "KS p < 0.00001**",
                       paste("KS p =",ifelse(pmat2 < a_sidak, paste0(format(round(pmat2, 5), scientific=FALSE), "**"),
                              round(pmat2, 3)))))
Dmat3 <- ifelse(is.na(Dmat2), "", 
                paste("KS D =",round(Dmat2, 2)))
diffmat3 <- ifelse(is.na(diffmat2), "", 
                paste("Est diff in means =", round(diffmat2, 2), "mm"))
SEmat3 <- ifelse(is.na(SEmat2), "", 
                paste("SE diff in means =",round(SEmat2, 2), "mm"))

allmat <- matrix(nrow=4*nrow(pmat3), ncol=ncol(pmat3))
allmat[seq(1, nrow(allmat), by=4),] <- diffmat3
allmat[seq(2, nrow(allmat), by=4),] <- SEmat3
allmat[seq(3, nrow(allmat), by=4),] <- Dmat3
allmat[seq(4, nrow(allmat), by=4),] <- pmat3
colnames(allmat) <- colnames(pmat3)
rownames(allmat) <- rep("", nrow(allmat))
rownames(allmat)[seq(1, nrow(allmat), by=4)] <- rownames(pmat3)

knitr::kable(allmat, align="c")
```

\pagebreak

## Effects of length correction (or not) on inferences

Abundance estimation using non-corrected lengths was presented, but a case could certainly be made for employing a "growth" correction as a means to correct for measurement bias in the first event.  Stratified estimates are reported below for all possible scenarios, in which length correction was performed for the first event using linear regression.

```{r, warning=FALSE, message=FALSE}
# just realized: it makes more sense to correct the first-event samples for bias 
# than to correct second-event samples for growth.  Argghh!  Here we go.
# yreg <- mr550$recaps$matched$FL_event2
# xreg <- mr550$recaps$matched$FL_event1
# correction_lm_550 <- lm(yreg ~ xreg)
# event1_raw$FLc <- predict(correction_lm_550, newdata = data.frame(xreg=event1_raw$FL))

yreg <- mr600$recaps$matched$FL_event2
xreg <- mr600$recaps$matched$FL_event1
correction_lm_600 <- lm(yreg ~ xreg)
event1_raw$FLc <- predict(correction_lm_600, newdata = data.frame(xreg=event1_raw$FL))

# c for corrected (length correction)
event1_550c <- event1_raw %>%
  filter(FLc >= 550)
event1_600c <- event1_raw %>%
  filter(FLc >= 600)

# force the measured lengths to be the same for recaps
# lookup table
length2 <- event2_550 %>%
  select(FL, `Tag Number`) %>%
  filter(!is.na(`Tag Number`)) %>%
  rename(FLc2=FL)
event1_550c <- event1_550c %>% 
  left_join(length2) %>%
  mutate(FLc = ifelse(!is.na(FLc2), FLc2, FLc))
event1_600c <- event1_600c %>% 
  left_join(length2) %>%
  mutate(FLc = ifelse(!is.na(FLc2), FLc2, FLc))

mr550c2 <- recapr_prep(ID="Tag Number", event1=event1_550c, event2=event2_550)
mr600c2 <- recapr_prep(ID="Tag Number", event1=event1_600c, event2=event2_600)


mr550c_strat <- stratify(mr550c2,
                        event_names = c("event1", "event2"),
                        column_names = c("FLc","FL"),
                        breaks = c(550, 650, 1200))
mr600c_strat <- stratify(mr600c2,
                        event_names = c("event1", "event2"),
                        column_names = c("FLc","FL"),
                        breaks = c(600, 650, 1200))

```

```{r}
magictable <- function(x) {
  n1 <- table(x$input_data$event1$FL_strat)
  n2 <- table(x$input_data$event2$FL_strat)
  m2 <- table(x$recaps$matched$FL_strat_event1)
  Nhat <- NChapman(n1, n2, m2)
  se_Nhat <- seChapman(n1, n2, m2)
  thetab1 <- cbind(n1, n2, m2, Nhat, se_Nhat)
  thetab2 <- rbind(thetab1, total=colSums(thetab1))
  thetab2[nrow(thetab2), ncol(thetab2)] <- sqrt(sum(thetab1[,ncol(thetab1)]^2))
  return(thetab2)
}
magictable_c <- function(x) {  # _c for corrected
  n1 <- table(x$input_data$event1$FLc_strat)
  n2 <- table(x$input_data$event2$FL_strat)
  m2 <- table(x$recaps$matched$FL_strat_event2)
  Nhat <- NChapman(n1, n2, m2)
  se_Nhat <- seChapman(n1, n2, m2)
  thetab1 <- cbind(n1, n2, m2, Nhat, se_Nhat)
  thetab2 <- rbind(thetab1, total=colSums(thetab1))
  thetab2[nrow(thetab2), ncol(thetab2)] <- sqrt(sum(thetab1[,ncol(thetab1)]^2))
  return(thetab2)
}
```

```{r}
# ### Non-corrected, lengths $\geq$ 550 mm FL
```

```{r}
# chunk_input <- mr550_strat
# 
# chunk_table <- magictable(chunk_input)
# knitr::kable(chunk_table, format.args=list(big.mark=','), digits=0)
# 
# Nhat_vec <- chunk_table[1:2, 4]
# seNhat_vec <- chunk_table[1:2, 5]
# 
# lengthbreaks <- c(550, 600, 650, 700, 800, 900, 1000, 1200) #550 to 1146
# ASL_table(length_cat = cut(chunk_input$input_data$event2$FL, breaks=lengthbreaks, right=FALSE, 
#                     dig.lab = 4),
#           stratum=as.numeric(chunk_input$input_data$event2$FL_strat),
#           Nhat=as.numeric(Nhat_vec),
#           se_Nhat = as.numeric(seNhat_vec)) %>% 
#   kable(format.args=list(big.mark=','), digits=c(0,3,3,0,0))
# 
# lengthbreaks <- c(550, 600, 1200) #550 to 1146
# ASL_table(length_cat = cut(chunk_input$input_data$event2$FL, breaks=lengthbreaks, right=FALSE, 
#                     dig.lab = 4),
#           stratum=as.numeric(chunk_input$input_data$event2$FL_strat),
#           Nhat=as.numeric(Nhat_vec),
#           se_Nhat = as.numeric(seNhat_vec)) %>% 
#   kable(format.args=list(big.mark=','), digits=c(0,3,3,0,0))
```

```{r}
# \pagebreak

### Growth-corrected, lengths $\geq$ 550 mm FL
```

```{r}
# chunk_input <- mr550c_strat
# 
# chunk_table <- magictable_c(chunk_input)
# knitr::kable(chunk_table, format.args=list(big.mark=','), digits=0)
# 
# Nhat_vec <- chunk_table[1:2, 4]
# seNhat_vec <- chunk_table[1:2, 5]
# 
# lengthbreaks <- c(550, 600, 650, 700, 800, 900, 1000, 1200) #550 to 1146
# ASL_table(length_cat = cut(chunk_input$input_data$event2$FL, breaks=lengthbreaks, right=FALSE, 
#                     dig.lab = 4),
#           stratum=as.numeric(chunk_input$input_data$event2$FL_strat),
#           Nhat=as.numeric(Nhat_vec),
#           se_Nhat = as.numeric(seNhat_vec)) %>% 
#   kable(format.args=list(big.mark=','), digits=c(0,3,3,0,0))
# 
# lengthbreaks <- c(550, 600, 1200) #550 to 1146
# ASL_table(length_cat = cut(chunk_input$input_data$event2$FL, breaks=lengthbreaks, right=FALSE, 
#                     dig.lab = 4),
#           stratum=as.numeric(chunk_input$input_data$event2$FL_strat),
#           Nhat=as.numeric(Nhat_vec),
#           se_Nhat = as.numeric(seNhat_vec)) %>% 
#   kable(format.args=list(big.mark=','), digits=c(0,3,3,0,0))
```

```{r}
# \pagebreak
```

### Non-corrected, lengths $\geq$ 600 mm FL

```{r}
chunk_input <- mr600_strat

chunk_table <- magictable(chunk_input)
knitr::kable(chunk_table, format.args=list(big.mark=','), digits=0)

Nhat_vec <- chunk_table[1:2, 4]
seNhat_vec <- chunk_table[1:2, 5]

lengthbreaks <- c(600, 650, 700, 800, 900, 1000, 1200) #550 to 1146
ASL_table(length_cat = cut(chunk_input$input_data$event2$FL, breaks=lengthbreaks, right=FALSE, 
                    dig.lab = 4),
          stratum=as.numeric(chunk_input$input_data$event2$FL_strat),
          Nhat=as.numeric(Nhat_vec),
          se_Nhat = as.numeric(seNhat_vec)) %>% 
  kable(format.args=list(big.mark=','), digits=c(0,3,3,0,0))
```

### Growth-corrected, lengths $\geq$ 600 mm FL

```{r}
chunk_input <- mr600c_strat

chunk_table <- magictable_c(chunk_input)
knitr::kable(chunk_table, format.args=list(big.mark=','), digits=0)

Nhat_vec <- chunk_table[1:2, 4]
seNhat_vec <- chunk_table[1:2, 5]

lengthbreaks <- c(600, 650, 700, 800, 900, 1000, 1200) #550 to 1146
ASL_table(length_cat = cut(chunk_input$input_data$event2$FL, breaks=lengthbreaks, right=FALSE, 
                    dig.lab = 4),
          stratum=as.numeric(chunk_input$input_data$event2$FL_strat),
          Nhat=as.numeric(Nhat_vec),
          se_Nhat = as.numeric(seNhat_vec)) %>% 
  kable(format.args=list(big.mark=','), digits=c(0,3,3,0,0))
```

\pagebreak

## Effect of bias due to immigration - Simulation

In order to investigate the relative magnitude of the bias potential due to immigration, a Monte Carlo simulation was employed assuming the following:

* The true abundance was equal to the abundance estimated for the smaller (600-649mm FL) size stratum.

* Sample sizes were equal to those corresponding to the smaller size stratum.

* The fraction migrating from the CROA to the MLSA was assumed to be 70%; that is, 70% of the fish subject to capture in the first event would be subject to capture in the second event.

* The MLSA (second-event) abundance was inflated by some number of fish that were not subject to capture in the first event.  A sequence of values were considered, and defined relative to the number of fish subject to capture in both events.  For example, if 7,000 fish were subject to capture in both events, a trial inflation value of 10% would imply that there were an extra 700 fish present, for a total true abundance of 7,700.

```{r}
nsim <- 10000# number of simulations to run for each p_res
```

Results are plotted below, showing the range of abundances estimated for `r format(nsim, big.mark = ",")` simulations.  It is immediately apparent that abundance estimates will be germane to the first event, but biased by the same relative amount that abundance was inflated in the second event.  For example, if 10,000 fish were present in the CROA in the first event, 7,000 of these were present in the MLSA in the second event, and an additional 10% (700) were also present in the MLSA, the expected value of the abundance estimate would be 11,000.  It is worth noting that the magnitude of this bias is actually relatively small with respect to the sampling variance of the estimate itself.

```{r, message=FALSE, warning=FALSE, fig.height=5, fig.width=7.5}
# ```{r, message=FALSE, warning=FALSE, fig.height=7.5, fig.width=4.5}

par(family="serif")
parmar <- par("mar")
par(mar=c(4,4,.5,1.5))

library(recapr)
library(jagshelper)


n1 <- table(mr600_strat$input_data$event1$FL_strat)
n2 <- table(mr600_strat$input_data$event2$FL_strat)
m2_1 <- table(mr600_strat$recaps$matched$FL_strat_event1)
m2_2 <- table(mr600_strat$recaps$matched$FL_strat_event2)

Nhat_vec <- NChapman(n1, n2, m2_1)

# assumed values
N_croa <- Nhat_vec[1]  # 24653  # 10*1000   # abundance at the CROA in winter
p_mlsa <- 0.7       # fraction of CROA that migrate to MLSA for summer

n1 <- n1[1] # 1049  # 1000  # sample sizes in both events
n2 <- n2[1] # 586   # 1000

N_mig <- N_croa*p_mlsa   # abundance at MLSA that migrated from CROA

p_res <- seq(from=0, to=1, by=0.05)  # factor by which MLSA abundance is "inflated"
                                     # by resident fish

Nhat <- matrix(nrow=nsim, ncol=length(p_res)) # initialize matrix for sim results

# loop over each value of p_res considered
for(i_p in seq_along(p_res)) {
  N_res <- N_mig*p_res[i_p]   # abundance of resident (non-migratory) MLSA fish
  N_mlsa <- N_mig + N_res     # abundance at MLSA (migratory and resident fish)
  
  # define fate vectors (each element is a fish)
  croa <- c(rep(TRUE, N_croa),  # fish at CROA in March
            rep(FALSE, N_res))  # fish not at CROA in March
  mlsa <- c(rep(TRUE, N_mig),            # CROA fish that migrated to MLSA
            rep(FALSE, N_croa - N_mig),  # CROA fish that did not migrate
            rep(TRUE, N_res))            # resident fish at MLSA
  
  # simulate sampling
  for(i_sim in 1:nsim) {
    sample1 <- sample(which(croa), n1)
    sample2 <- sample(which(mlsa), n2)
    recaps <- intersect(sample1, sample2)
    m2 <- length(recaps)
    
    Nhat[i_sim, i_p] <- NChapman(n1, n2, m2)   # from recapr package
  }
}

# par(mfrow=c(2,1))
par(mfrow=c(1,2))

# from jagshelper package
caterpillar(Nhat, x=p_res, mean=TRUE,
            xlab="MLSA inflation factor", ylab="Est Abundance",
            col=1,
            ylim=c(5000, 45000))
abline(h=N_croa, lty=3)
abline(N_croa, N_croa, lty=2)
legend("topleft", 
       legend=c("sim estimates", "true abundance (1st event)", "theoretical"),
       lwd=c(3, 1, 1), pch=c(16, NA, NA), col=c(1, 1, 1), lty=c(1, 3, 2))

caterpillar((Nhat-N_croa)/N_croa, x=p_res, mean=TRUE,
            xlab="MLSA inflation factor", ylab="Relative bias (prop)",
            col=1,
            ylim=c(-0.5, 3))
abline(h=0, lty=3)
abline(0, 1, lty=2)
legend("topleft", legend=c("rel bias of sims", "(no bias)", "theoretical bias"),
       lwd=c(3, 1, 1), pch=c(16, NA, NA), col=c(1, 1, 1), lty=c(1, 3, 2))

```

figure caption something like:

Simulated abundance estimates under a sequence of bias-generating scenarios (`r format(nsim, big.mark=',')` replications).  The heavy and light vertical bars represent 50% and 95% intervals, respectively.  Filled circles represent mean simulated values, which serve as approximations of expected values.  The dotted line represents the unbiased case, and the dashed line represents the case in which the relative bias is equal to the second-event inflation factor, as described previously.
